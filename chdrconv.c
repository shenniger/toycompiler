#include <alloca.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <clang-c/Index.h>

const char *PREAMBLE =
    "; This file has been autogenerated from %s by chdrconv.c.\n"
    "; Do not change it manually!\n";

struct Arg {
  const char *Name;
  CXType Type;
};

static void writeType(CXType a, const char *name) {
  switch (a.kind) {
#define TYPE(name, k)                                                          \
  case CXType_##name:                                                          \
    printf k;                                                                  \
    break;

    TYPE(Void, ("void"))
    TYPE(Bool, ("i8"))
    TYPE(Char_U, ("char"))
    TYPE(UChar, ("u8"))
    TYPE(UShort, ("u16"))
    TYPE(UInt, ("u32"))
    TYPE(ULong, ("u32"))
    TYPE(ULongLong, ("u64"))
    TYPE(Char_S, ("char"))
    TYPE(SChar, ("i8"))
    TYPE(Short, ("i16"))
    TYPE(Int, ("i32"))
    TYPE(Long, ("i32"))
    TYPE(LongLong, ("i64"))
    TYPE(Float, ("sfloat"))
    TYPE(Double, ("float"))
  /*  TYPE(Record, )
  TYPE(Enum, )
  TYPE(Typedef, )
  */
  case CXType_Pointer: {
    CXType pointee = clang_getPointeeType(a);
    if (pointee.kind != CXType_Void) {
      printf("(ptr ");
      writeType(pointee, name);
      printf(")");
    } else {
      printf("ptr");
    }
    break;
  }
  case CXType_Elaborated:
    writeType(clang_Type_getNamedType(a), name);
    break;
  default:
    fprintf(stderr, "ERR: unknown type in %s!\n", name);
    exit(1);
    break;
  }
}

static void writeFun(CXType rettype, const char *name, struct Arg *args,
                     unsigned numargs) {
  printf("(funproto %s (", name);
  for (unsigned i = 0; i < numargs; ++i) {
    printf("(");
    writeType(args->Type, name);
    printf(" %s) ", args->Name);
  }
  printf(") ");
  writeType(rettype, name);
  printf(")\n");
}

static enum CXChildVisitResult visitor(CXCursor cursor, CXCursor parent,
                                       CXClientData client_data) {
  enum CXCursorKind kind;

  (void)parent, (void)client_data;

  kind = clang_getCursorKind(cursor);
  if (kind == CXCursor_FunctionDecl) {
    CXType rettype = clang_getResultType(clang_getCursorType(cursor));
    unsigned num = clang_Cursor_getNumArguments(cursor);
    struct Arg *args = alloca(sizeof(struct Arg) * num);
    for (unsigned i = 0; i < num; ++i) {
      CXCursor a = clang_Cursor_getArgument(cursor, i);
      args[i].Name = clang_getCString(clang_getCursorSpelling(a));
      args[i].Type = clang_getCursorType(a);
    }
    writeFun(rettype, clang_getCString(clang_getCursorSpelling(cursor)), args,
             num);
  }

  return CXChildVisit_Continue;
}

int main(int argc, char **argv) {
  CXIndex index;
  CXTranslationUnit unit;
  CXCursor cursor;
  const char *fakeargv[1];
  uint8_t err = 0;

  if (argc != 2) {
    fputs("USAGE: [main header]\n", stderr);
    return 1;
  }

  index = clang_createIndex(0, 0);
  fakeargv[0] = argv[1];
  unit = clang_parseTranslationUnit(index, 0, fakeargv,
                                    sizeof(fakeargv) / sizeof(const char *), 0,
                                    0, CXTranslationUnit_None);
  cursor = clang_getTranslationUnitCursor(unit);

  for (unsigned I = 0, N = clang_getNumDiagnostics(unit); I != N; ++I) {
    CXDiagnostic diag = clang_getDiagnostic(unit, I);
    CXString str =
        clang_formatDiagnostic(diag, clang_defaultDiagnosticDisplayOptions());
    fprintf(stderr, "CLANG: %s\n", clang_getCString(str));
    clang_disposeString(str);
    if (clang_getDiagnosticSeverity(diag) >= CXDiagnostic_Error) {
      err = 1;
    }
  }

  if (err) {
    return 1;
  }

  /* preamble */
  printf(PREAMBLE, argv[1]);

  /* collect all interesting stuff */
  clang_visitChildren(cursor, &visitor, NULL);

  clang_disposeTranslationUnit(unit);
  clang_disposeIndex(index);
  return 0;
}
